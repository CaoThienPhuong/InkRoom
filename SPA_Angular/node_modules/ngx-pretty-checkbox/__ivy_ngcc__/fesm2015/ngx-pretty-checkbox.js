import { Directive, ElementRef, Component, ChangeDetectionStrategy, Renderer2, Input, Attribute, EventEmitter, ViewEncapsulation, ChangeDetectorRef, ViewChild, Output, ContentChild, ContentChildren, Optional, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["will-change", ""];
const _c1 = [[["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c2 = ["[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
const _c3 = ["inputElem"];
const _c4 = ["stateElem"];
function NgxPrettyCheckboxComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3, 4);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementStart(3, "label");
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c5 = [[["ngx-p-indeterminate"], ["p-indeterminate"], ["ngx-p-hover"], ["p-hover"], ["ngx-p-toggle"], ["p-toggle"]], [["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c6 = ["ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle", "[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
const _c7 = function (a0) { return [a0]; };
function NgxPrettyCheckboxWillChangeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementStart(2, "label");
    ɵngcc0.ɵɵprojection(3, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c7, ctx_r1.color ? "p-" + ctx_r1.color + (ctx_r1.outline ? "-o" : "") : ""));
} }
function NgxPrettyRadioComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3, 4);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementStart(3, "label");
    ɵngcc0.ɵɵprojection(4, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c8 = [[["ngx-p-hover"], ["p-hover"], ["ngx-p-toggle"], ["p-toggle"]], [["", "pIcon", ""], ["", "p-icon", ""], ["", "pSvg", ""], ["", "p-svg", ""], ["", "pImage", ""], ["", "p-image", ""]], "*"];
const _c9 = ["ngx-p-hover, p-hover, ngx-p-toggle, p-toggle", "[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]", "*"];
function NgxPrettyRadioWillChangeComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementStart(2, "label");
    ɵngcc0.ɵɵprojection(3, 2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c7, ctx_r1.color ? "p-" + ctx_r1.color + (ctx_r1.outline ? "-o" : "") : ""));
} }
class NgxPrettyIconDirective {
    constructor(elemRef) {
        this.elemRef = elemRef;
        this.elemRef.nativeElement.classList.add('icon');
    }
}
NgxPrettyIconDirective.ɵfac = function NgxPrettyIconDirective_Factory(t) { return new (t || NgxPrettyIconDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettyIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyIconDirective, selectors: [["", "pIcon", ""], ["", "p-icon", ""]] });
NgxPrettyIconDirective.ctorParameters = () => [
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyIconDirective, [{
        type: Directive,
        args: [{
                selector: '[pIcon], [p-icon]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

class NgxPrettyImageDirective {
    constructor(elemRef) {
        this.elemRef = elemRef;
        this.elemRef.nativeElement.classList.add('image');
    }
}
NgxPrettyImageDirective.ɵfac = function NgxPrettyImageDirective_Factory(t) { return new (t || NgxPrettyImageDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettyImageDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyImageDirective, selectors: [["", "pImage", ""], ["", "p-image", ""]] });
NgxPrettyImageDirective.ctorParameters = () => [
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyImageDirective, [{
        type: Directive,
        args: [{
                selector: '[pImage], [p-image]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

class NgxPrettySvgDirective {
    constructor(elemRef) {
        this.elemRef = elemRef;
    }
    ngAfterViewInit() {
        this.elemRef.nativeElement.classList.add('svg');
    }
}
NgxPrettySvgDirective.ɵfac = function NgxPrettySvgDirective_Factory(t) { return new (t || NgxPrettySvgDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxPrettySvgDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettySvgDirective, selectors: [["", "pSvg", ""], ["", "p-svg", ""]] });
NgxPrettySvgDirective.ctorParameters = () => [
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettySvgDirective, [{
        type: Directive,
        args: [{
                selector: '[pSvg], [p-svg]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();

var PrettyCheckBoxToggleType;
(function (PrettyCheckBoxToggleType) {
    PrettyCheckBoxToggleType["On"] = "on";
    PrettyCheckBoxToggleType["Off"] = "off";
})(PrettyCheckBoxToggleType || (PrettyCheckBoxToggleType = {}));
var PrettyCheckboxStroke;
(function (PrettyCheckboxStroke) {
    // Accept Null
    PrettyCheckboxStroke["Fill"] = "fill";
    PrettyCheckboxStroke["Thick"] = "thick";
    PrettyCheckboxStroke["Slim"] = "slim"; // Switch
})(PrettyCheckboxStroke || (PrettyCheckboxStroke = {}));
var PrettyCheckboxShape;
(function (PrettyCheckboxShape) {
    // Accept Null
    PrettyCheckboxShape["Curve"] = "curve";
    PrettyCheckboxShape["Round"] = "round";
})(PrettyCheckboxShape || (PrettyCheckboxShape = {}));
var PrettyCheckboxColor;
(function (PrettyCheckboxColor) {
    PrettyCheckboxColor["Primary"] = "primary";
    PrettyCheckboxColor["Success"] = "success";
    PrettyCheckboxColor["Info"] = "info";
    PrettyCheckboxColor["Warning"] = "warning";
    PrettyCheckboxColor["Danger"] = "danger";
})(PrettyCheckboxColor || (PrettyCheckboxColor = {}));
var PrettyCheckboxAnimation;
(function (PrettyCheckboxAnimation) {
    PrettyCheckboxAnimation["Smooth"] = "smooth";
    PrettyCheckboxAnimation["Jelly"] = "jelly";
    PrettyCheckboxAnimation["Tada"] = "tada";
    PrettyCheckboxAnimation["Rotate"] = "rotate";
    PrettyCheckboxAnimation["Pulse"] = "pulse";
})(PrettyCheckboxAnimation || (PrettyCheckboxAnimation = {}));

// import { DEFAULT_PREFIX, DEFAULT_OUTLINE_PREFIX } from './model/params';
function getColorClassName(color, outline) {
    if (!color) {
        return null;
    }
    return 'p-' + color + (outline ? '-o' : '');
}
function strToBoolean(str) {
    if (typeof str === 'boolean') {
        return str;
    }
    const regex = /^\s*(true|1|on|enable)\s*$/i;
    return regex.test(str);
}

class NgxPrettyHoverWillChangeComponent {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyHoverWillChangeComponent.ɵfac = function NgxPrettyHoverWillChangeComponent_Factory(t) { return new (t || NgxPrettyHoverWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyHoverWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyHoverWillChangeComponent, selectors: [["ngx-p-hover", "will-change", ""], ["p-hover", "will-change", ""]], hostAttrs: [1, "state", "p-is-hover"], inputs: { outline: "outline", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyHoverWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyHoverWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyHoverWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyHoverWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                host: {
                    class: `state p-is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class NgxPrettyHoverComponent {
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `p-${this._color}${this._outline ? '-o' : ''}`);
        }
    }
}
NgxPrettyHoverComponent.ɵfac = function NgxPrettyHoverComponent_Factory(t) { return new (t || NgxPrettyHoverComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyHoverComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyHoverComponent, selectors: [["ngx-p-hover", 3, "will-change", ""], ["p-hover", 3, "will-change", ""]], hostAttrs: [1, "state", "p-is-hover"], ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyHoverComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyHoverComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyHoverComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                host: {
                    class: `state p-is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, null); })();

class NgxPrettyIndeterminateWillChangeComponent {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyIndeterminateWillChangeComponent.ɵfac = function NgxPrettyIndeterminateWillChangeComponent_Factory(t) { return new (t || NgxPrettyIndeterminateWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyIndeterminateWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyIndeterminateWillChangeComponent, selectors: [["ngx-p-indeterminate", "will-change", ""], ["p-indeterminate", "will-change", ""]], hostAttrs: [1, "state", "p-is-indeterminate"], inputs: { outline: "outline", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyIndeterminateWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyIndeterminateWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyIndeterminateWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                host: {
                    class: `state p-is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

class NgxPrettyIndeterminateComponent {
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `p-${this._color}${this._outline ? '-o' : ''}`);
        }
    }
}
NgxPrettyIndeterminateComponent.ɵfac = function NgxPrettyIndeterminateComponent_Factory(t) { return new (t || NgxPrettyIndeterminateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyIndeterminateComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyIndeterminateComponent, selectors: [["ngx-p-indeterminate", 3, "will-change", ""], ["p-indeterminate", 3, "will-change", ""]], hostAttrs: [1, "state", "p-is-indeterminate"], ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyIndeterminateComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyIndeterminateComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyIndeterminateComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                host: {
                    class: `state p-is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, null); })();

class NgxPrettyToggleWillChangeComponent {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    get isToggleOn() { return this.type === PrettyCheckBoxToggleType.On; }
    get isToggleOff() { return this.type === PrettyCheckBoxToggleType.Off; }
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyToggleWillChangeComponent.ɵfac = function NgxPrettyToggleWillChangeComponent_Factory(t) { return new (t || NgxPrettyToggleWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxPrettyToggleWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyToggleWillChangeComponent, selectors: [["ngx-p-toggle", "will-change", ""], ["p-toggle", "will-change", ""]], hostAttrs: [1, "state"], hostVars: 4, hostBindings: function NgxPrettyToggleWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-on", ctx.isToggleOn)("p-off", ctx.isToggleOff);
    } }, inputs: { outline: "outline", type: "type", color: "color" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyToggleWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyToggleWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyToggleWillChangeComponent.propDecorators = {
    type: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyToggleWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n<label><ng-content></ng-content></label>",
                host: {
                    'class': 'state',
                    '[class.p-on]': 'isToggleOn',
                    '[class.p-off]': 'isToggleOff'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { outline: [{
            type: Input
        }], type: [{
            type: Input
        }], color: [{
            type: Input
        }] }); })();

// tslint:disable:use-host-property-decorator
class NgxPrettyToggleComponent {
    constructor(el, renderer, _outline = false, _color, _type) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
        this._type = _type;
    }
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `p-${this._color}${this._outline ? '-o' : ''}`);
        }
        this.renderer.addClass(this.el.nativeElement, `p-${this._type}`);
    }
}
NgxPrettyToggleComponent.ɵfac = function NgxPrettyToggleComponent_Factory(t) { return new (t || NgxPrettyToggleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color'), ɵngcc0.ɵɵinjectAttribute('type')); };
NgxPrettyToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyToggleComponent, selectors: [["ngx-p-toggle", 3, "will-change", ""], ["p-toggle", 3, "will-change", ""]], hostAttrs: [1, "state"], ngContentSelectors: _c2, decls: 3, vars: 0, template: function NgxPrettyToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "label");
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NgxPrettyToggleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: PrettyCheckBoxToggleType, decorators: [{ type: Attribute, args: ['type',] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyToggleComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                host: {
                    class: 'state'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }, { type: PrettyCheckBoxToggleType, decorators: [{
                type: Attribute,
                args: ['type']
            }] }]; }, null); })();

class NgxPrettyCheckboxComponent {
    constructor(renderer, el, cd, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color) {
        this.renderer = renderer;
        this.el = el;
        this.cd = cd;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this.checked = false;
        this.disabled = false;
        // @HostBinding(`class.p-locked`)
        this.lock = false;
        this.change = new EventEmitter();
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    ngAfterViewInit() {
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `p-switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `p-bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `p-has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `p-plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `p-${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `p-${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `p-${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `p-icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `p-svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `p-image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `p-has-hover`);
        }
        if (this._indeterminateDir || this._indeterminateWillChangeDir) {
            this.renderer.addClass(el, `p-has-indeterminate`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `p-toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `p-default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `p-${this._color}${this._outline ? '-o' : ''}`);
        }
    }
    // ---------- PRIVATE METHODS ---------
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
    // ---------- PUBLIC METHODS ---------
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxComponent.ɵfac = function NgxPrettyCheckboxComponent_Factory(t) { return new (t || NgxPrettyCheckboxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinjectAttribute('stroke'), ɵngcc0.ɵɵinjectAttribute('shape'), ɵngcc0.ɵɵinjectAttribute('animation'), ɵngcc0.ɵɵinjectAttribute('isSwitch'), ɵngcc0.ɵɵinjectAttribute('bigger'), ɵngcc0.ɵɵinjectAttribute('enableFocus'), ɵngcc0.ɵɵinjectAttribute('plain'), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color')); };
NgxPrettyCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyCheckboxComponent, selectors: [["ngx-pretty-checkbox", 3, "will-change", ""], ["p-checkbox", 3, "will-change", ""]], contentQueries: function NgxPrettyCheckboxComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, 0);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComps = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComps = _t);
    } }, viewQuery: function NgxPrettyCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, 3);
        ɵngcc0.ɵɵviewQuery(_c4, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stateElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 2, hostBindings: function NgxPrettyCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-locked", ctx.lock);
    } }, inputs: { checked: "checked", disabled: "disabled", lock: "lock", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyCheckbox"], ngContentSelectors: _c6, decls: 4, vars: 4, consts: [["type", "checkbox", 3, "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 4, "ngIf"], [1, "state"], ["stateElem", ""]], template: function NgxPrettyCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        const _r3 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyCheckboxComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyCheckboxComponent_div_2_Template, 5, 0, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
NgxPrettyCheckboxComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
NgxPrettyCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _indeterminateDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                template: "<input\r\n  #inputElem\r\n  type=\"checkbox\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\r\n\r\n  <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n  <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\r\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'pretty',
                    '[class.p-locked]': 'lock'
                },
                exportAs: 'ngxPrettyCheckbox'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: PrettyCheckboxStroke, decorators: [{
                type: Attribute,
                args: ['stroke']
            }] }, { type: PrettyCheckboxShape, decorators: [{
                type: Attribute,
                args: ['shape']
            }] }, { type: PrettyCheckboxAnimation, decorators: [{
                type: Attribute,
                args: ['animation']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['isSwitch']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['bigger']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['enableFocus']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['plain']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }]; }, { checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], lock: [{
            type: Input
        }], change: [{
            type: Output
        }], value: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], _stateElem: [{
            type: ViewChild,
            args: ['stateElem', { static: false }]
        }], _iconDir: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgDir: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imgDir: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _indeterminateDir: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateComponent, { static: false }]
        }], _indeterminateWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateWillChangeComponent, { static: false }]
        }], _toggleComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }] }); })();

class NgxPrettyCheckboxWillChangeComponent {
    constructor(cd) {
        this.cd = cd;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        this.isSwitch = false;
        this.lock = false;
        this.bigger = false;
        this.enableFocus = false;
        this.plain = false; // To remove the border ( when checkbox is checked )
    }
    // ---------- STROKE ----------
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    get _isIndeterminate() { return this._indeterminateComp || this._indeterminateWillChangeComp; }
    // ---------- PRIVATE METHODS ---------
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    // ---------- PUBLIC METHODS ---------
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxWillChangeComponent.ɵfac = function NgxPrettyCheckboxWillChangeComponent_Factory(t) { return new (t || NgxPrettyCheckboxWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NgxPrettyCheckboxWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyCheckboxWillChangeComponent, selectors: [["ngx-pretty-checkbox", "will-change", ""], ["p-checkbox", "will-change", ""]], contentQueries: function NgxPrettyCheckboxWillChangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIndeterminateWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, 0);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imageElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._indeterminateWillChangeComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComp = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComp = _t);
    } }, viewQuery: function NgxPrettyCheckboxWillChangeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 44, hostBindings: function NgxPrettyCheckboxWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-switch", ctx.isSwitch)("p-locked", ctx.lock)("p-bigger", ctx.bigger)("p-has-focus", ctx.enableFocus)("p-plain", ctx.plain)("p-fill", ctx._isFill)("p-slim", ctx._isSlim)("p-thick", ctx._isThick)("p-curve", ctx._isCurve)("p-round", ctx._isRound)("p-smooth", ctx._isSmooth)("p-jelly", ctx._isJelly)("p-tada", ctx._isTada)("p-rotate", ctx._isRotate)("p-pulse", ctx._isPulse)("p-toggle", ctx._isToggle)("p-default", ctx._isDefault)("p-icon", ctx._iconElem)("p-svg", ctx._svgElem)("p-image", ctx._imageElem)("p-has-hover", ctx._isHover)("p-has-indeterminate", ctx._isIndeterminate);
    } }, inputs: { outline: "outline", checked: "checked", disabled: "disabled", isSwitch: "isSwitch", lock: "lock", bigger: "bigger", enableFocus: "enableFocus", plain: "plain", stroke: "stroke", shape: "shape", animation: "animation", color: "color", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyCheckboxWillChange"], attrs: _c0, ngContentSelectors: _c6, decls: 4, vars: 4, consts: [["type", "checkbox", 3, "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 3, "ngClass", 4, "ngIf"], [1, "state", 3, "ngClass"]], template: function NgxPrettyCheckboxWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        const _r2 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyCheckboxWillChangeComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyCheckboxWillChangeComponent_div_2_Template, 4, 3, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NgxPrettyCheckboxWillChangeComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NgxPrettyCheckboxWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    isSwitch: [{ type: Input }],
    lock: [{ type: Input }],
    bigger: [{ type: Input }],
    enableFocus: [{ type: Input }],
    plain: [{ type: Input }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _iconElem: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _indeterminateComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                template: "<input\r\n  #inputElem\r\n  type=\"checkbox\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div\r\n  *ngIf=\"!_isToggle\"\r\n  class=\"state\"\r\n  [ngClass]=\"[ color ? 'p-' + color + (outline ? '-o' : '') : '' ]\">\r\n\r\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n    <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content\r\n  select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\">\r\n</ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'pretty',
                    '[class.p-switch]': 'isSwitch',
                    '[class.p-locked]': 'lock',
                    '[class.p-bigger]': 'bigger',
                    '[class.p-has-focus]': 'enableFocus',
                    '[class.p-plain]': 'plain',
                    '[class.p-fill]': '_isFill',
                    '[class.p-slim]': '_isSlim',
                    '[class.p-thick]': '_isThick',
                    '[class.p-curve]': '_isCurve',
                    '[class.p-round]': '_isRound',
                    '[class.p-smooth]': '_isSmooth',
                    '[class.p-jelly]': '_isJelly',
                    '[class.p-tada]': '_isTada',
                    '[class.p-rotate]': '_isRotate',
                    '[class.p-pulse]': '_isPulse',
                    '[class.p-toggle]': '_isToggle',
                    '[class.p-default]': '_isDefault',
                    '[class.p-icon]': '_iconElem',
                    '[class.p-svg]': '_svgElem',
                    '[class.p-image]': '_imageElem',
                    '[class.p-has-hover]': '_isHover',
                    '[class.p-has-indeterminate]': '_isIndeterminate'
                },
                exportAs: 'ngxPrettyCheckboxWillChange'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { change: [{
            type: Output
        }], outline: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSwitch: [{
            type: Input
        }], lock: [{
            type: Input
        }], bigger: [{
            type: Input
        }], enableFocus: [{
            type: Input
        }], plain: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], stroke: [{
            type: Input
        }], shape: [{
            type: Input
        }], animation: [{
            type: Input
        }], color: [{
            type: Input
        }], value: [{
            type: Input
        }], _toggleComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }], _iconElem: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgElem: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imageElem: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _hoverComp: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _indeterminateComp: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateComponent, { static: false }]
        }], _indeterminateWillChangeComp: [{
            type: ContentChild,
            args: [NgxPrettyIndeterminateWillChangeComponent, { static: false }]
        }] }); })();

let nextId = 1;
class NgxPrettyRadioGroupDirective {
    constructor() {
        this.name = 'p-radio' + nextId++;
        this.change = new EventEmitter();
    }
    _emitChange(event) {
        this.change.emit(event);
    }
}
NgxPrettyRadioGroupDirective.ɵfac = function NgxPrettyRadioGroupDirective_Factory(t) { return new (t || NgxPrettyRadioGroupDirective)(); };
NgxPrettyRadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPrettyRadioGroupDirective, selectors: [["ngx-pretty-radio-group"], ["p-radio-group"]], outputs: { change: "change" }, exportAs: ["ngxRadioGroup"] });
NgxPrettyRadioGroupDirective.ctorParameters = () => [];
NgxPrettyRadioGroupDirective.propDecorators = {
    change: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioGroupDirective, [{
        type: Directive,
        args: [{
                selector: 'ngx-pretty-radio-group, p-radio-group',
                // providers: [NgxPrettyRadioService],
                exportAs: 'ngxRadioGroup'
            }]
    }], function () { return []; }, { change: [{
            type: Output
        }] }); })();

class NgxPrettyRadioComponent {
    constructor(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color, _name) {
        this.renderer = renderer;
        this.el = el;
        this.radioGroup = radioGroup;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._name = _name;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        if (!this._name && this.radioGroup) {
            this._name = this.radioGroup.name;
        }
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    ngAfterViewInit() {
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `p-switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `p-bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `p-has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `p-plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `p-${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `p-${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `p-${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `p-icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `p-svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `p-image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `p-has-hover`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `p-toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `p-default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `p-${this._color}${this._outline ? '-o' : ''}`);
        }
    }
    // ---------- METHODS ---------
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
}
NgxPrettyRadioComponent.ɵfac = function NgxPrettyRadioComponent_Factory(t) { return new (t || NgxPrettyRadioComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxPrettyRadioGroupDirective, 8), ɵngcc0.ɵɵinjectAttribute('stroke'), ɵngcc0.ɵɵinjectAttribute('shape'), ɵngcc0.ɵɵinjectAttribute('animation'), ɵngcc0.ɵɵinjectAttribute('isSwitch'), ɵngcc0.ɵɵinjectAttribute('bigger'), ɵngcc0.ɵɵinjectAttribute('enableFocus'), ɵngcc0.ɵɵinjectAttribute('plain'), ɵngcc0.ɵɵinjectAttribute('outline'), ɵngcc0.ɵɵinjectAttribute('color'), ɵngcc0.ɵɵinjectAttribute('name')); };
NgxPrettyRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyRadioComponent, selectors: [["ngx-pretty-radio", 3, "will-change", ""], ["p-radio", 3, "will-change", ""]], contentQueries: function NgxPrettyRadioComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, 0);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imgDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComps = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComps = _t);
    } }, viewQuery: function NgxPrettyRadioComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, 3);
        ɵngcc0.ɵɵviewQuery(_c4, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._stateElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 2, hostBindings: function NgxPrettyRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-locked", ctx.lock);
    } }, inputs: { checked: "checked", disabled: "disabled", lock: "lock", value: "value" }, outputs: { change: "change" }, exportAs: ["ngxPrettyRadio"], ngContentSelectors: _c9, decls: 4, vars: 5, consts: [["type", "radio", 3, "name", "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 4, "ngIf"], [1, "state"], ["stateElem", ""]], template: function NgxPrettyRadioComponent_Template(rf, ctx) { if (rf & 1) {
        const _r3 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c8);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyRadioComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyRadioComponent_div_2_Template, 5, 0, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("name", ctx._name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2 });
NgxPrettyRadioComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['name',] }] }
];
NgxPrettyRadioComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                template: "<input\r\n  #inputElem\r\n  type=\"radio\"\r\n  [name]=\"_name\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\r\n\r\n  <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n  <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>",
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'pretty',
                    '[class.p-locked]': 'lock'
                },
                exportAs: 'ngxPrettyRadio'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: NgxPrettyRadioGroupDirective, decorators: [{
                type: Optional
            }] }, { type: PrettyCheckboxStroke, decorators: [{
                type: Attribute,
                args: ['stroke']
            }] }, { type: PrettyCheckboxShape, decorators: [{
                type: Attribute,
                args: ['shape']
            }] }, { type: PrettyCheckboxAnimation, decorators: [{
                type: Attribute,
                args: ['animation']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['isSwitch']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['bigger']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['enableFocus']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['plain']
            }] }, { type: undefined, decorators: [{
                type: Attribute,
                args: ['outline']
            }] }, { type: PrettyCheckboxColor, decorators: [{
                type: Attribute,
                args: ['color']
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ['name']
            }] }]; }, { checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], lock: [{
            type: Input
        }], change: [{
            type: Output
        }], value: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], _stateElem: [{
            type: ViewChild,
            args: ['stateElem', { static: false }]
        }], _iconDir: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgDir: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imgDir: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _toggleComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComps: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }] }); })();

class NgxPrettyRadioWillChangeComponent {
    constructor(radioGroup) {
        this.radioGroup = radioGroup;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        this.isSwitch = false;
        this.lock = false;
        this.bigger = false;
        this.enableFocus = false;
        this.plain = false; // To remove the border ( when checkbox is checked )
        if (radioGroup) {
            this.radioGroupName = radioGroup.name;
        }
    }
    // ---------- STROKE ----------
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    // ---------- METHODS ---------
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
}
NgxPrettyRadioWillChangeComponent.ɵfac = function NgxPrettyRadioWillChangeComponent_Factory(t) { return new (t || NgxPrettyRadioWillChangeComponent)(ɵngcc0.ɵɵdirectiveInject(NgxPrettyRadioGroupDirective, 8)); };
NgxPrettyRadioWillChangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxPrettyRadioWillChangeComponent, selectors: [["ngx-pretty-radio", "will-change", ""], ["p-radio", "will-change", ""]], contentQueries: function NgxPrettyRadioWillChangeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyIconDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettySvgDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyImageDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverWillChangeComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyHoverComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleComponent, 0);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxPrettyToggleWillChangeComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._iconElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._imageElem = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverWillChangeDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._hoverComp = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleComp = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._toggleWillChangeComp = _t);
    } }, viewQuery: function NgxPrettyRadioWillChangeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElem = _t.first);
    } }, hostAttrs: [1, "pretty"], hostVars: 42, hostBindings: function NgxPrettyRadioWillChangeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("p-switch", ctx.isSwitch)("p-locked", ctx.lock)("p-bigger", ctx.bigger)("p-has-focus", ctx.enableFocus)("p-plain", ctx.plain)("p-fill", ctx._isFill)("p-thick", ctx._isSlim)("p-slim", ctx._isThick)("p-curve", ctx._isCurve)("p-round", ctx._isRound)("p-smooth", ctx._isSmooth)("p-jelly", ctx._isJelly)("p-tada", ctx._isTada)("p-rotate", ctx._isRotate)("p-pulse", ctx._isPulse)("p-toggle", ctx._isToggle)("p-default", ctx._isDefault)("p-icon", ctx._iconElem)("p-svg", ctx._svgElem)("p-image", ctx._imageElem)("p-has-hover", ctx._isHover);
    } }, inputs: { outline: "outline", checked: "checked", disabled: "disabled", isSwitch: "isSwitch", lock: "lock", bigger: "bigger", enableFocus: "enableFocus", plain: "plain", stroke: "stroke", shape: "shape", animation: "animation", color: "color", value: "value", name: "name" }, outputs: { change: "change" }, exportAs: ["ngxPrettyRadio"], attrs: _c0, ngContentSelectors: _c6, decls: 4, vars: 5, consts: [["type", "radio", 3, "name", "value", "checked", "disabled", "change"], ["inputElem", ""], ["class", "state", 3, "ngClass", 4, "ngIf"], [1, "state", 3, "ngClass"]], template: function NgxPrettyRadioWillChangeComponent_Template(rf, ctx) { if (rf & 1) {
        const _r2 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NgxPrettyRadioWillChangeComponent_Template_input_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const _r0 = ɵngcc0.ɵɵreference(1); return ctx._onChange($event, _r0.checked, _r0.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NgxPrettyRadioWillChangeComponent_div_2_Template, 4, 3, "div", 2);
        ɵngcc0.ɵɵprojection(3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("name", ctx.name || ctx.radioGroupName)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx._isToggle);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgClass], encapsulation: 2, changeDetection: 0 });
NgxPrettyRadioWillChangeComponent.ctorParameters = () => [
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] }
];
NgxPrettyRadioWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    isSwitch: [{ type: Input }],
    lock: [{ type: Input }],
    bigger: [{ type: Input }],
    enableFocus: [{ type: Input }],
    plain: [{ type: Input }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _iconElem: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyRadioWillChangeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                template: "<input\r\n  #inputElem\r\n  type=\"radio\"\r\n  [name]=\"name || radioGroupName\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div *ngIf=\"!_isToggle\" class=\"state\"\r\n    [ngClass]=\"[ color ? 'p-' + color + (outline ? '-o' : '') : '' ]\">\r\n\r\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n    <label><ng-content></ng-content></label>\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'pretty',
                    '[class.p-switch]': 'isSwitch',
                    '[class.p-locked]': 'lock',
                    '[class.p-bigger]': 'bigger',
                    '[class.p-has-focus]': 'enableFocus',
                    '[class.p-plain]': 'plain',
                    '[class.p-fill]': '_isFill',
                    '[class.p-thick]': '_isSlim',
                    '[class.p-slim]': '_isThick',
                    '[class.p-curve]': '_isCurve',
                    '[class.p-round]': '_isRound',
                    '[class.p-smooth]': '_isSmooth',
                    '[class.p-jelly]': '_isJelly',
                    '[class.p-tada]': '_isTada',
                    '[class.p-rotate]': '_isRotate',
                    '[class.p-pulse]': '_isPulse',
                    '[class.p-toggle]': '_isToggle',
                    '[class.p-default]': '_isDefault',
                    '[class.p-icon]': '_iconElem',
                    '[class.p-svg]': '_svgElem',
                    '[class.p-image]': '_imageElem',
                    '[class.p-has-hover]': '_isHover'
                },
                exportAs: 'ngxPrettyRadio'
            }]
    }], function () { return [{ type: NgxPrettyRadioGroupDirective, decorators: [{
                type: Optional
            }] }]; }, { change: [{
            type: Output
        }], outline: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSwitch: [{
            type: Input
        }], lock: [{
            type: Input
        }], bigger: [{
            type: Input
        }], enableFocus: [{
            type: Input
        }], plain: [{
            type: Input
        }], _inputElem: [{
            type: ViewChild,
            args: ['inputElem', { static: true }]
        }], stroke: [{
            type: Input
        }], shape: [{
            type: Input
        }], animation: [{
            type: Input
        }], color: [{
            type: Input
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], _toggleComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleComponent]
        }], _toggleWillChangeComp: [{
            type: ContentChildren,
            args: [NgxPrettyToggleWillChangeComponent]
        }], _iconElem: [{
            type: ContentChild,
            args: [NgxPrettyIconDirective, { static: false }]
        }], _svgElem: [{
            type: ContentChild,
            args: [NgxPrettySvgDirective, { static: false }]
        }], _imageElem: [{
            type: ContentChild,
            args: [NgxPrettyImageDirective, { static: false }]
        }], _hoverWillChangeDir: [{
            type: ContentChild,
            args: [NgxPrettyHoverWillChangeComponent, { static: false }]
        }], _hoverComp: [{
            type: ContentChild,
            args: [NgxPrettyHoverComponent, { static: false }]
        }] }); })();

const DECLARATIONS = [
    NgxPrettyCheckboxComponent,
    NgxPrettyCheckboxWillChangeComponent,
    NgxPrettyIconDirective,
    NgxPrettySvgDirective,
    NgxPrettyImageDirective,
    NgxPrettyToggleComponent,
    NgxPrettyToggleWillChangeComponent,
    NgxPrettyHoverComponent,
    NgxPrettyHoverWillChangeComponent,
    NgxPrettyIndeterminateComponent,
    NgxPrettyIndeterminateWillChangeComponent,
    NgxPrettyRadioGroupDirective,
    NgxPrettyRadioComponent,
    NgxPrettyRadioWillChangeComponent
];
class NgxPrettyCheckboxModule {
}
NgxPrettyCheckboxModule.ɵfac = function NgxPrettyCheckboxModule_Factory(t) { return new (t || NgxPrettyCheckboxModule)(); };
NgxPrettyCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPrettyCheckboxModule });
NgxPrettyCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, FormsModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxPrettyCheckboxModule, { declarations: function () { return [NgxPrettyCheckboxComponent, NgxPrettyCheckboxWillChangeComponent, NgxPrettyIconDirective, NgxPrettySvgDirective, NgxPrettyImageDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioComponent, NgxPrettyRadioWillChangeComponent]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [NgxPrettyCheckboxComponent, NgxPrettyCheckboxWillChangeComponent, NgxPrettyIconDirective, NgxPrettySvgDirective, NgxPrettyImageDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioComponent, NgxPrettyRadioWillChangeComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPrettyCheckboxModule, [{
        type: NgModule,
        args: [{
                declarations: [DECLARATIONS],
                imports: [CommonModule, FormsModule],
                exports: [DECLARATIONS]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-pretty-checkbox
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxPrettyCheckboxComponent, NgxPrettyCheckboxModule, NgxPrettyCheckboxWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIconDirective, NgxPrettyImageDirective, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioWillChangeComponent, NgxPrettySvgDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, PrettyCheckBoxToggleType, PrettyCheckboxAnimation, PrettyCheckboxColor, PrettyCheckboxShape, PrettyCheckboxStroke };

//# sourceMappingURL=ngx-pretty-checkbox.js.map