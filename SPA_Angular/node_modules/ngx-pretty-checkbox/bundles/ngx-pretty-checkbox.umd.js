(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('ngx-pretty-checkbox', ['exports', '@angular/core', '@angular/common', '@angular/forms'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-pretty-checkbox'] = {}, global.ng.core, global.ng.common, global.ng.forms));
}(this, (function (exports, core, common, forms) { 'use strict';

    var NgxPrettyIconDirective = /** @class */ (function () {
        function NgxPrettyIconDirective(elemRef) {
            this.elemRef = elemRef;
            this.elemRef.nativeElement.classList.add('icon');
        }
        return NgxPrettyIconDirective;
    }());
    NgxPrettyIconDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[pIcon], [p-icon]'
                },] }
    ];
    NgxPrettyIconDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };

    var NgxPrettyImageDirective = /** @class */ (function () {
        function NgxPrettyImageDirective(elemRef) {
            this.elemRef = elemRef;
            this.elemRef.nativeElement.classList.add('image');
        }
        return NgxPrettyImageDirective;
    }());
    NgxPrettyImageDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[pImage], [p-image]'
                },] }
    ];
    NgxPrettyImageDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };

    var NgxPrettySvgDirective = /** @class */ (function () {
        function NgxPrettySvgDirective(elemRef) {
            this.elemRef = elemRef;
        }
        NgxPrettySvgDirective.prototype.ngAfterViewInit = function () {
            this.elemRef.nativeElement.classList.add('svg');
        };
        return NgxPrettySvgDirective;
    }());
    NgxPrettySvgDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[pSvg], [p-svg]'
                },] }
    ];
    NgxPrettySvgDirective.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };

    exports.PrettyCheckBoxToggleType = void 0;
    (function (PrettyCheckBoxToggleType) {
        PrettyCheckBoxToggleType["On"] = "on";
        PrettyCheckBoxToggleType["Off"] = "off";
    })(exports.PrettyCheckBoxToggleType || (exports.PrettyCheckBoxToggleType = {}));
    exports.PrettyCheckboxStroke = void 0;
    (function (PrettyCheckboxStroke) {
        // Accept Null
        PrettyCheckboxStroke["Fill"] = "fill";
        PrettyCheckboxStroke["Thick"] = "thick";
        PrettyCheckboxStroke["Slim"] = "slim"; // Switch
    })(exports.PrettyCheckboxStroke || (exports.PrettyCheckboxStroke = {}));
    exports.PrettyCheckboxShape = void 0;
    (function (PrettyCheckboxShape) {
        // Accept Null
        PrettyCheckboxShape["Curve"] = "curve";
        PrettyCheckboxShape["Round"] = "round";
    })(exports.PrettyCheckboxShape || (exports.PrettyCheckboxShape = {}));
    exports.PrettyCheckboxColor = void 0;
    (function (PrettyCheckboxColor) {
        PrettyCheckboxColor["Primary"] = "primary";
        PrettyCheckboxColor["Success"] = "success";
        PrettyCheckboxColor["Info"] = "info";
        PrettyCheckboxColor["Warning"] = "warning";
        PrettyCheckboxColor["Danger"] = "danger";
    })(exports.PrettyCheckboxColor || (exports.PrettyCheckboxColor = {}));
    exports.PrettyCheckboxAnimation = void 0;
    (function (PrettyCheckboxAnimation) {
        PrettyCheckboxAnimation["Smooth"] = "smooth";
        PrettyCheckboxAnimation["Jelly"] = "jelly";
        PrettyCheckboxAnimation["Tada"] = "tada";
        PrettyCheckboxAnimation["Rotate"] = "rotate";
        PrettyCheckboxAnimation["Pulse"] = "pulse";
    })(exports.PrettyCheckboxAnimation || (exports.PrettyCheckboxAnimation = {}));

    // import { DEFAULT_PREFIX, DEFAULT_OUTLINE_PREFIX } from './model/params';
    function getColorClassName(color, outline) {
        if (!color) {
            return null;
        }
        return 'p-' + color + (outline ? '-o' : '');
    }
    function strToBoolean(str) {
        if (typeof str === 'boolean') {
            return str;
        }
        var regex = /^\s*(true|1|on|enable)\s*$/i;
        return regex.test(str);
    }

    var NgxPrettyHoverWillChangeComponent = /** @class */ (function () {
        function NgxPrettyHoverWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        NgxPrettyHoverWillChangeComponent.prototype.ngOnChanges = function (changes) {
            if (changes.color || changes.outline) {
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        return NgxPrettyHoverWillChangeComponent;
    }());
    NgxPrettyHoverWillChangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                    host: {
                        class: "state p-is-hover"
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyHoverWillChangeComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    NgxPrettyHoverWillChangeComponent.propDecorators = {
        color: [{ type: core.Input }],
        outline: [{ type: core.Input }]
    };

    var NgxPrettyHoverComponent = /** @class */ (function () {
        function NgxPrettyHoverComponent(el, renderer, _outline, _color) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
        }
        NgxPrettyHoverComponent.prototype.ngAfterViewInit = function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "p-" + this._color + (this._outline ? '-o' : ''));
            }
        };
        return NgxPrettyHoverComponent;
    }());
    NgxPrettyHoverComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                    host: {
                        class: "state p-is-hover"
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyHoverComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
        { type: exports.PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
    ]; };

    var NgxPrettyIndeterminateWillChangeComponent = /** @class */ (function () {
        function NgxPrettyIndeterminateWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        NgxPrettyIndeterminateWillChangeComponent.prototype.ngOnChanges = function (changes) {
            if (changes.color || changes.outline) {
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        return NgxPrettyIndeterminateWillChangeComponent;
    }());
    NgxPrettyIndeterminateWillChangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                    host: {
                        class: "state p-is-indeterminate"
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyIndeterminateWillChangeComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
        color: [{ type: core.Input }],
        outline: [{ type: core.Input }]
    };

    var NgxPrettyIndeterminateComponent = /** @class */ (function () {
        function NgxPrettyIndeterminateComponent(el, renderer, _outline, _color) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
        }
        NgxPrettyIndeterminateComponent.prototype.ngAfterViewInit = function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "p-" + this._color + (this._outline ? '-o' : ''));
            }
        };
        return NgxPrettyIndeterminateComponent;
    }());
    NgxPrettyIndeterminateComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                    host: {
                        class: "state p-is-indeterminate"
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyIndeterminateComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
        { type: exports.PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
    ]; };

    var NgxPrettyToggleWillChangeComponent = /** @class */ (function () {
        function NgxPrettyToggleWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOn", {
            get: function () { return this.type === exports.PrettyCheckBoxToggleType.On; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOff", {
            get: function () { return this.type === exports.PrettyCheckBoxToggleType.Off; },
            enumerable: false,
            configurable: true
        });
        NgxPrettyToggleWillChangeComponent.prototype.ngOnChanges = function (changes) {
            if (changes.color || changes.outline) {
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        return NgxPrettyToggleWillChangeComponent;
    }());
    NgxPrettyToggleWillChangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n<label><ng-content></ng-content></label>",
                    host: {
                        'class': 'state',
                        '[class.p-on]': 'isToggleOn',
                        '[class.p-off]': 'isToggleOff',
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyToggleWillChangeComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    NgxPrettyToggleWillChangeComponent.propDecorators = {
        type: [{ type: core.Input }],
        color: [{ type: core.Input }],
        outline: [{ type: core.Input }]
    };

    // tslint:disable:use-host-property-decorator
    var NgxPrettyToggleComponent = /** @class */ (function () {
        function NgxPrettyToggleComponent(el, renderer, _outline, _color, _type) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
            this._type = _type;
        }
        NgxPrettyToggleComponent.prototype.ngAfterViewInit = function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "p-" + this._color + (this._outline ? '-o' : ''));
            }
            this.renderer.addClass(this.el.nativeElement, "p-" + this._type);
        };
        return NgxPrettyToggleComponent;
    }());
    NgxPrettyToggleComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                    template: "<ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n<label><ng-content></ng-content></label>",
                    host: {
                        class: 'state'
                    },
                    changeDetection: core.ChangeDetectionStrategy.OnPush
                },] }
    ];
    NgxPrettyToggleComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
        { type: exports.PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] },
        { type: exports.PrettyCheckBoxToggleType, decorators: [{ type: core.Attribute, args: ['type',] }] }
    ]; };

    var NgxPrettyCheckboxComponent = /** @class */ (function () {
        function NgxPrettyCheckboxComponent(renderer, el, cd, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color) {
            if (_isSwitch === void 0) { _isSwitch = false; }
            if (_bigger === void 0) { _bigger = false; }
            if (_enableFocus === void 0) { _enableFocus = false; }
            if (_plain === void 0) { _plain = false; }
            if (_outline === void 0) { _outline = false; }
            this.renderer = renderer;
            this.el = el;
            this.cd = cd;
            this._stroke = _stroke;
            this._shape = _shape;
            this._animation = _animation;
            this._isSwitch = _isSwitch;
            this._bigger = _bigger;
            this._enableFocus = _enableFocus;
            this._plain = _plain;
            this._outline = _outline;
            this._color = _color;
            this.checked = false;
            this.disabled = false;
            // @HostBinding(`class.p-locked`)
            this.lock = false;
            this.change = new core.EventEmitter();
            this._isSwitch = strToBoolean(this._isSwitch);
            this._bigger = strToBoolean(this._bigger);
            this._enableFocus = strToBoolean(this._enableFocus);
            this._plain = strToBoolean(this._plain);
            this._outline = strToBoolean(this._outline);
        }
        NgxPrettyCheckboxComponent.prototype.ngAfterViewInit = function () {
            var el = this.el.nativeElement;
            if (this._isSwitch) {
                this.renderer.addClass(el, "p-switch");
            }
            if (this._bigger) {
                this.renderer.addClass(el, "p-bigger");
            }
            if (this._enableFocus) {
                this.renderer.addClass(el, "p-has-focus");
            }
            if (this._plain) {
                this.renderer.addClass(el, "p-plain");
            }
            if (this._stroke) {
                this.renderer.addClass(el, "p-" + this._stroke);
            }
            if (this._shape) {
                this.renderer.addClass(el, "p-" + this._shape);
            }
            if (this._animation) {
                this.renderer.addClass(el, "p-" + this._animation);
            }
            if (this._iconDir) {
                this.renderer.addClass(el, "p-icon");
            }
            if (this._svgDir) {
                this.renderer.addClass(el, "p-svg");
            }
            if (this._imgDir) {
                this.renderer.addClass(el, "p-image");
            }
            if (this._hoverDir || this._hoverWillChangeDir) {
                this.renderer.addClass(el, "p-has-hover");
            }
            if (this._indeterminateDir || this._indeterminateWillChangeDir) {
                this.renderer.addClass(el, "p-has-indeterminate");
            }
            if (this._isToggle) {
                this.renderer.addClass(el, "p-toggle");
            }
            if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
                this.renderer.addClass(el, "p-default");
            }
            // STATE ELEM
            if (this._color && !this._isToggle) {
                this.renderer.addClass(this._stateElem.nativeElement, "p-" + this._color + (this._outline ? '-o' : ''));
            }
        };
        // ---------- PRIVATE METHODS ---------
        NgxPrettyCheckboxComponent.prototype._onChange = function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.checked = checked;
            this.change.emit({ value: value, checked: checked, event: event });
        };
        Object.defineProperty(NgxPrettyCheckboxComponent.prototype, "_isToggle", {
            get: function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
            enumerable: false,
            configurable: true
        });
        // ---------- PUBLIC METHODS ---------
        NgxPrettyCheckboxComponent.prototype.setIndeterminate = function (value) {
            if (value === void 0) { value = true; }
            this._inputElem.nativeElement.indeterminate = value;
        };
        NgxPrettyCheckboxComponent.prototype.forceCheck = function (check) {
            this.checked = check;
            this.cd.markForCheck();
        };
        return NgxPrettyCheckboxComponent;
    }());
    NgxPrettyCheckboxComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                    template: "<input\r\n  #inputElem\r\n  type=\"checkbox\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\r\n\r\n  <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n  <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\r\n",
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        'class': 'pretty',
                        '[class.p-locked]': 'lock'
                    },
                    exportAs: 'ngxPrettyCheckbox'
                },] }
    ];
    NgxPrettyCheckboxComponent.ctorParameters = function () { return [
        { type: core.Renderer2 },
        { type: core.ElementRef },
        { type: core.ChangeDetectorRef },
        { type: exports.PrettyCheckboxStroke, decorators: [{ type: core.Attribute, args: ['stroke',] }] },
        { type: exports.PrettyCheckboxShape, decorators: [{ type: core.Attribute, args: ['shape',] }] },
        { type: exports.PrettyCheckboxAnimation, decorators: [{ type: core.Attribute, args: ['animation',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['isSwitch',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['bigger',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['enableFocus',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['plain',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
        { type: exports.PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
    ]; };
    NgxPrettyCheckboxComponent.propDecorators = {
        checked: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        value: [{ type: core.Input }],
        lock: [{ type: core.Input }],
        _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
        _stateElem: [{ type: core.ViewChild, args: ['stateElem', { static: false },] }],
        change: [{ type: core.Output }],
        _iconDir: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgDir: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imgDir: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverDir: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _indeterminateDir: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
        _indeterminateWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
        _toggleComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
    };

    var NgxPrettyCheckboxWillChangeComponent = /** @class */ (function () {
        function NgxPrettyCheckboxWillChangeComponent(cd) {
            this.cd = cd;
            this.change = new core.EventEmitter();
            this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            this.checked = false;
            this.disabled = false;
            // ----- INPUTS AND BINDING ------
            this.isSwitch = false;
            this.lock = false;
            this.bigger = false;
            this.enableFocus = false;
            this.plain = false; // To remove the border ( when checkbox is checked )
        }
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isFill", {
            // ---------- STROKE ----------
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Fill; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSlim", {
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Slim; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isThick", {
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Thick; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isCurve", {
            // ---------- SHAPE ----------
            get: function () { return this.shape === exports.PrettyCheckboxShape.Curve; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRound", {
            get: function () { return this.shape === exports.PrettyCheckboxShape.Round; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSmooth", {
            // ---------- ANIMATION ----------
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Smooth; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isJelly", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Jelly; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isTada", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Tada; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRotate", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Rotate; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isPulse", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Pulse; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isToggle", {
            get: function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isDefault", {
            // DEFAULT
            get: function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isHover", {
            get: function () { return this._hoverComp || this._hoverWillChangeDir; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isIndeterminate", {
            get: function () { return this._indeterminateComp || this._indeterminateWillChangeComp; },
            enumerable: false,
            configurable: true
        });
        // ---------- PRIVATE METHODS ---------
        NgxPrettyCheckboxWillChangeComponent.prototype._onChange = function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up
            event.stopPropagation();
            this.checked = checked;
            this.change.emit({ value: value, checked: checked, event: event });
        };
        // ---------- PUBLIC METHODS ---------
        NgxPrettyCheckboxWillChangeComponent.prototype.setIndeterminate = function (value) {
            if (value === void 0) { value = true; }
            this._inputElem.nativeElement.indeterminate = value;
        };
        NgxPrettyCheckboxWillChangeComponent.prototype.forceCheck = function (check) {
            this.checked = check;
            this.cd.markForCheck();
        };
        return NgxPrettyCheckboxWillChangeComponent;
    }());
    NgxPrettyCheckboxWillChangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                    template: "<input\r\n  #inputElem\r\n  type=\"checkbox\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div\r\n  *ngIf=\"!_isToggle\"\r\n  class=\"state\"\r\n  [ngClass]=\"[ color ? 'p-' + color + (outline ? '-o' : '') : '' ]\">\r\n\r\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n\r\n    <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content\r\n  select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\">\r\n</ng-content>",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        'class': 'pretty',
                        '[class.p-switch]': 'isSwitch',
                        '[class.p-locked]': 'lock',
                        '[class.p-bigger]': 'bigger',
                        '[class.p-has-focus]': 'enableFocus',
                        '[class.p-plain]': 'plain',
                        '[class.p-fill]': '_isFill',
                        '[class.p-slim]': '_isSlim',
                        '[class.p-thick]': '_isThick',
                        '[class.p-curve]': '_isCurve',
                        '[class.p-round]': '_isRound',
                        '[class.p-smooth]': '_isSmooth',
                        '[class.p-jelly]': '_isJelly',
                        '[class.p-tada]': '_isTada',
                        '[class.p-rotate]': '_isRotate',
                        '[class.p-pulse]': '_isPulse',
                        '[class.p-toggle]': '_isToggle',
                        '[class.p-default]': '_isDefault',
                        '[class.p-icon]': '_iconElem',
                        '[class.p-svg]': '_svgElem',
                        '[class.p-image]': '_imageElem',
                        '[class.p-has-hover]': '_isHover',
                        '[class.p-has-indeterminate]': '_isIndeterminate',
                    },
                    exportAs: 'ngxPrettyCheckboxWillChange'
                },] }
    ];
    NgxPrettyCheckboxWillChangeComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef }
    ]; };
    NgxPrettyCheckboxWillChangeComponent.propDecorators = {
        _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
        change: [{ type: core.Output }],
        stroke: [{ type: core.Input }],
        shape: [{ type: core.Input }],
        animation: [{ type: core.Input }],
        color: [{ type: core.Input }],
        outline: [{ type: core.Input }],
        checked: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        value: [{ type: core.Input }],
        isSwitch: [{ type: core.Input }],
        lock: [{ type: core.Input }],
        bigger: [{ type: core.Input }],
        enableFocus: [{ type: core.Input }],
        plain: [{ type: core.Input }],
        _toggleComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
        _iconElem: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgElem: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imageElem: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _hoverComp: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _indeterminateComp: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
        _indeterminateWillChangeComp: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }]
    };

    var nextId = 1;
    var NgxPrettyRadioGroupDirective = /** @class */ (function () {
        function NgxPrettyRadioGroupDirective() {
            this.name = 'p-radio' + nextId++;
            this.change = new core.EventEmitter();
        }
        NgxPrettyRadioGroupDirective.prototype._emitChange = function (event) {
            this.change.emit(event);
        };
        return NgxPrettyRadioGroupDirective;
    }());
    NgxPrettyRadioGroupDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: 'ngx-pretty-radio-group, p-radio-group',
                    // providers: [NgxPrettyRadioService],
                    exportAs: 'ngxRadioGroup'
                },] }
    ];
    NgxPrettyRadioGroupDirective.ctorParameters = function () { return []; };
    NgxPrettyRadioGroupDirective.propDecorators = {
        change: [{ type: core.Output }]
    };

    var NgxPrettyRadioComponent = /** @class */ (function () {
        function NgxPrettyRadioComponent(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color, _name) {
            if (_isSwitch === void 0) { _isSwitch = false; }
            if (_bigger === void 0) { _bigger = false; }
            if (_enableFocus === void 0) { _enableFocus = false; }
            if (_plain === void 0) { _plain = false; }
            if (_outline === void 0) { _outline = false; }
            this.renderer = renderer;
            this.el = el;
            this.radioGroup = radioGroup;
            this._stroke = _stroke;
            this._shape = _shape;
            this._animation = _animation;
            this._isSwitch = _isSwitch;
            this._bigger = _bigger;
            this._enableFocus = _enableFocus;
            this._plain = _plain;
            this._outline = _outline;
            this._color = _color;
            this._name = _name;
            this.checked = false;
            this.disabled = false;
            this.lock = false;
            this.change = new core.EventEmitter();
            if (!this._name && this.radioGroup) {
                this._name = this.radioGroup.name;
            }
            this._isSwitch = strToBoolean(this._isSwitch);
            this._bigger = strToBoolean(this._bigger);
            this._enableFocus = strToBoolean(this._enableFocus);
            this._plain = strToBoolean(this._plain);
            this._outline = strToBoolean(this._outline);
        }
        NgxPrettyRadioComponent.prototype.ngAfterViewInit = function () {
            var el = this.el.nativeElement;
            if (this._isSwitch) {
                this.renderer.addClass(el, "p-switch");
            }
            if (this._bigger) {
                this.renderer.addClass(el, "p-bigger");
            }
            if (this._enableFocus) {
                this.renderer.addClass(el, "p-has-focus");
            }
            if (this._plain) {
                this.renderer.addClass(el, "p-plain");
            }
            if (this._stroke) {
                this.renderer.addClass(el, "p-" + this._stroke);
            }
            if (this._shape) {
                this.renderer.addClass(el, "p-" + this._shape);
            }
            if (this._animation) {
                this.renderer.addClass(el, "p-" + this._animation);
            }
            if (this._iconDir) {
                this.renderer.addClass(el, "p-icon");
            }
            if (this._svgDir) {
                this.renderer.addClass(el, "p-svg");
            }
            if (this._imgDir) {
                this.renderer.addClass(el, "p-image");
            }
            if (this._hoverDir || this._hoverWillChangeDir) {
                this.renderer.addClass(el, "p-has-hover");
            }
            if (this._isToggle) {
                this.renderer.addClass(el, "p-toggle");
            }
            if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
                this.renderer.addClass(el, "p-default");
            }
            // STATE ELEM
            if (this._color && !this._isToggle) {
                this.renderer.addClass(this._stateElem.nativeElement, "p-" + this._color + (this._outline ? '-o' : ''));
            }
        };
        // ---------- METHODS ---------
        NgxPrettyRadioComponent.prototype._onChange = function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.change.emit({ value: value, checked: checked, event: event });
            if (this.radioGroup) {
                this.radioGroup._emitChange({ value: value, checked: checked, event: event });
            }
        };
        Object.defineProperty(NgxPrettyRadioComponent.prototype, "_isToggle", {
            get: function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
            enumerable: false,
            configurable: true
        });
        return NgxPrettyRadioComponent;
    }());
    NgxPrettyRadioComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                    template: "<input\r\n  #inputElem\r\n  type=\"radio\"\r\n  [name]=\"_name\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\r\n\r\n  <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n  <label><ng-content></ng-content></label>\r\n\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>",
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        'class': 'pretty',
                        '[class.p-locked]': 'lock'
                    },
                    exportAs: 'ngxPrettyRadio'
                },] }
    ];
    NgxPrettyRadioComponent.ctorParameters = function () { return [
        { type: core.Renderer2 },
        { type: core.ElementRef },
        { type: NgxPrettyRadioGroupDirective, decorators: [{ type: core.Optional }] },
        { type: exports.PrettyCheckboxStroke, decorators: [{ type: core.Attribute, args: ['stroke',] }] },
        { type: exports.PrettyCheckboxShape, decorators: [{ type: core.Attribute, args: ['shape',] }] },
        { type: exports.PrettyCheckboxAnimation, decorators: [{ type: core.Attribute, args: ['animation',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['isSwitch',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['bigger',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['enableFocus',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['plain',] }] },
        { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
        { type: exports.PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] },
        { type: String, decorators: [{ type: core.Attribute, args: ['name',] }] }
    ]; };
    NgxPrettyRadioComponent.propDecorators = {
        checked: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        value: [{ type: core.Input }],
        lock: [{ type: core.Input }],
        _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
        _stateElem: [{ type: core.ViewChild, args: ['stateElem', { static: false },] }],
        change: [{ type: core.Output }],
        _iconDir: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgDir: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imgDir: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverDir: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _toggleComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
    };

    var NgxPrettyRadioWillChangeComponent = /** @class */ (function () {
        function NgxPrettyRadioWillChangeComponent(radioGroup) {
            this.radioGroup = radioGroup;
            this.change = new core.EventEmitter();
            this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            this.checked = false;
            this.disabled = false;
            // ----- INPUTS AND BINDING ------
            this.isSwitch = false;
            this.lock = false;
            this.bigger = false;
            this.enableFocus = false;
            this.plain = false; // To remove the border ( when checkbox is checked )
            if (radioGroup) {
                this.radioGroupName = radioGroup.name;
            }
        }
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isFill", {
            // ---------- STROKE ----------
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Fill; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSlim", {
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Slim; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isThick", {
            get: function () { return this.stroke === exports.PrettyCheckboxStroke.Thick; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isCurve", {
            // ---------- SHAPE ----------
            get: function () { return this.shape === exports.PrettyCheckboxShape.Curve; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRound", {
            get: function () { return this.shape === exports.PrettyCheckboxShape.Round; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSmooth", {
            // ---------- ANIMATION ----------
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Smooth; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isJelly", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Jelly; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isTada", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Tada; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRotate", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Rotate; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isPulse", {
            get: function () { return this.animation === exports.PrettyCheckboxAnimation.Pulse; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isToggle", {
            get: function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isDefault", {
            // DEFAULT
            get: function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isHover", {
            get: function () { return this._hoverComp || this._hoverWillChangeDir; },
            enumerable: false,
            configurable: true
        });
        // ---------- METHODS ---------
        NgxPrettyRadioWillChangeComponent.prototype._onChange = function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.change.emit({ value: value, checked: checked, event: event });
            if (this.radioGroup) {
                this.radioGroup._emitChange({ value: value, checked: checked, event: event });
            }
        };
        return NgxPrettyRadioWillChangeComponent;
    }());
    NgxPrettyRadioWillChangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                    template: "<input\r\n  #inputElem\r\n  type=\"radio\"\r\n  [name]=\"name || radioGroupName\"\r\n  [value]=\"value\"\r\n  [checked]=\"checked\"\r\n  [disabled]=\"disabled\"\r\n  (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\r\n\r\n<div *ngIf=\"!_isToggle\" class=\"state\"\r\n    [ngClass]=\"[ color ? 'p-' + color + (outline ? '-o' : '') : '' ]\">\r\n\r\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\r\n    <label><ng-content></ng-content></label>\r\n</div>\r\n\r\n<ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    encapsulation: core.ViewEncapsulation.None,
                    host: {
                        'class': 'pretty',
                        '[class.p-switch]': 'isSwitch',
                        '[class.p-locked]': 'lock',
                        '[class.p-bigger]': 'bigger',
                        '[class.p-has-focus]': 'enableFocus',
                        '[class.p-plain]': 'plain',
                        '[class.p-fill]': '_isFill',
                        '[class.p-thick]': '_isSlim',
                        '[class.p-slim]': '_isThick',
                        '[class.p-curve]': '_isCurve',
                        '[class.p-round]': '_isRound',
                        '[class.p-smooth]': '_isSmooth',
                        '[class.p-jelly]': '_isJelly',
                        '[class.p-tada]': '_isTada',
                        '[class.p-rotate]': '_isRotate',
                        '[class.p-pulse]': '_isPulse',
                        '[class.p-toggle]': '_isToggle',
                        '[class.p-default]': '_isDefault',
                        '[class.p-icon]': '_iconElem',
                        '[class.p-svg]': '_svgElem',
                        '[class.p-image]': '_imageElem',
                        '[class.p-has-hover]': '_isHover',
                    },
                    exportAs: 'ngxPrettyRadio'
                },] }
    ];
    NgxPrettyRadioWillChangeComponent.ctorParameters = function () { return [
        { type: NgxPrettyRadioGroupDirective, decorators: [{ type: core.Optional }] }
    ]; };
    NgxPrettyRadioWillChangeComponent.propDecorators = {
        _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
        change: [{ type: core.Output }],
        stroke: [{ type: core.Input }],
        shape: [{ type: core.Input }],
        animation: [{ type: core.Input }],
        color: [{ type: core.Input }],
        outline: [{ type: core.Input }],
        checked: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        value: [{ type: core.Input }],
        name: [{ type: core.Input }],
        isSwitch: [{ type: core.Input }],
        lock: [{ type: core.Input }],
        bigger: [{ type: core.Input }],
        enableFocus: [{ type: core.Input }],
        plain: [{ type: core.Input }],
        _toggleComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
        _iconElem: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgElem: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imageElem: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _hoverComp: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }]
    };

    var DECLARATIONS = [
        NgxPrettyCheckboxComponent,
        NgxPrettyCheckboxWillChangeComponent,
        NgxPrettyIconDirective,
        NgxPrettySvgDirective,
        NgxPrettyImageDirective,
        NgxPrettyToggleComponent,
        NgxPrettyToggleWillChangeComponent,
        NgxPrettyHoverComponent,
        NgxPrettyHoverWillChangeComponent,
        NgxPrettyIndeterminateComponent,
        NgxPrettyIndeterminateWillChangeComponent,
        NgxPrettyRadioGroupDirective,
        NgxPrettyRadioComponent,
        NgxPrettyRadioWillChangeComponent
    ];
    var NgxPrettyCheckboxModule = /** @class */ (function () {
        function NgxPrettyCheckboxModule() {
        }
        return NgxPrettyCheckboxModule;
    }());
    NgxPrettyCheckboxModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [DECLARATIONS],
                    imports: [common.CommonModule, forms.FormsModule],
                    exports: [DECLARATIONS]
                },] }
    ];

    /*
     * Public API Surface of ngx-pretty-checkbox
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgxPrettyCheckboxComponent = NgxPrettyCheckboxComponent;
    exports.NgxPrettyCheckboxModule = NgxPrettyCheckboxModule;
    exports.NgxPrettyCheckboxWillChangeComponent = NgxPrettyCheckboxWillChangeComponent;
    exports.NgxPrettyHoverComponent = NgxPrettyHoverComponent;
    exports.NgxPrettyHoverWillChangeComponent = NgxPrettyHoverWillChangeComponent;
    exports.NgxPrettyIconDirective = NgxPrettyIconDirective;
    exports.NgxPrettyImageDirective = NgxPrettyImageDirective;
    exports.NgxPrettyIndeterminateComponent = NgxPrettyIndeterminateComponent;
    exports.NgxPrettyIndeterminateWillChangeComponent = NgxPrettyIndeterminateWillChangeComponent;
    exports.NgxPrettyRadioComponent = NgxPrettyRadioComponent;
    exports.NgxPrettyRadioGroupDirective = NgxPrettyRadioGroupDirective;
    exports.NgxPrettyRadioWillChangeComponent = NgxPrettyRadioWillChangeComponent;
    exports.NgxPrettySvgDirective = NgxPrettySvgDirective;
    exports.NgxPrettyToggleComponent = NgxPrettyToggleComponent;
    exports.NgxPrettyToggleWillChangeComponent = NgxPrettyToggleWillChangeComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-pretty-checkbox.umd.js.map
